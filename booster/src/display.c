/**
 * File: display.c
 * Author: Diego Parrilla Santamar√≠a
 * Date: December 2024
 * Copyright: 2024 - GOODDATA LABS SL
 * Description: Common functions for the display
 */

#include "display.h"

static uint32_t display_address = 0;
static uint32_t display_command_address = 0;
static uint32_t displays_highres_transtable_address = 0;

// Static assert to ensure buffer size fits within uint32_t
_Static_assert(DISPLAY_BUFFER_SIZE <= UINT32_MAX,
               "Buffer size exceeds allowed limits");

// Allocate the framebuffer
static unsigned char u8g2_buffer[DISPLAY_BUFFER_SIZE] = {0};

// Global u8g2 structure
static u8g2_t u8g2 = {0};

// Dummy byte communication function
static unsigned char u8x8_dummy_byte(void *u8x8, unsigned char msg,
                                     unsigned char arg_int, void *arg_ptr) {
  return 1;  // Always return success
}

// Dummy GPIO function
static unsigned char u8x8_dummy_gpio(void *u8x8, unsigned char msg,
                                     unsigned char arg_int, void *arg_ptr) {
  return 1;  // Always return success
}

// Dummy Command/Data function
static unsigned char u8x8_cad_dummy(void *u8x8, unsigned char msg,
                                    unsigned char arg_int, void *arg_ptr) {
  return 1;  // Always return success
}

#ifdef DISPLAY_ATARIST
static const u8x8_display_info_t u8x8_ataristlow_320x200_display_info = {
    /* chip_enable_level = */ 0,
    /* chip_disable_level = */ 1,

    /* post_chip_enable_wait_ns = */ 30, /* G242CX Datasheet p5 */
    /* pre_chip_disable_wait_ns = */ 10, /* G242CX Datasheet p5 */
    /* reset_pulse_width_ms = */ 1,
    /* post_reset_wait_ms = */ 6,
    /* sda_setup_time_ns = */ 20,
    /* sck_pulse_width_ns = */ 140,
    /* sck_clock_hz = */ 1000000UL, /* since Arduino 1.6.0, the SPI bus speed in
                                       Hz. Should be
                                       1000000000/sck_pulse_width_ns */
    /* spi_mode = */ 0,
    /* i2c_bus_clock_100kHz = */ 4,
    /* data_setup_time_ns = */ 120,   /* G242CX Datasheet p5 */
    /* write_pulse_width_ns = */ 220, /* G242CX Datasheet p5 */
    /* tile_width = */ 40,
    /* tile_height = */ 25,
    /* default_x_offset = */ 0,
    /* flipmode_x_offset = */ 0,
    /* pixel_width = */ 320,
    /* pixel_height = */ 200};

// Getter function for u8g2 structure
u8g2_t *display_get_u8g2_ref() { return &u8g2; }

// Getter function for display address
uint32_t get_display_address() { return display_address; }

// Setter function for display address
void set_display_address(uint32_t address) { display_address = address; }

// Getter function for display command address
uint32_t get_display_command_address() { return display_command_address; }

// Setter function for display command address
void set_display_command_address(uint32_t address) {
  display_command_address = address;
}

// Getter function for highres translation table address
uint32_t get_displays_highres_transtable_address() {
  return displays_highres_transtable_address;
}

// Setter function for highres translation table address
void set_displays_highres_transtable_address(uint32_t address) {
  displays_highres_transtable_address = address;
}

unsigned char u8x8_d_custom(u8x8_t *u8x8, unsigned char msg,
                            unsigned char arg_int, void *arg_ptr) {
  if (msg == U8X8_MSG_DISPLAY_SETUP_MEMORY) {
    u8x8_d_helper_display_setup_memory(u8x8,
                                       &u8x8_ataristlow_320x200_display_info);
  }
  return 1;
}
#endif

/**
 * @brief Displays a QR code onto a bitmap buffer with support for border and
 * scaling.
 *
 * @param qrcode          The QR code data generated by qrcodegen.
 * @param display_address Pointer to the display buffer (bitmap array).
 * @param display_size_x  Width of the display in pixels.
 * @param display_size_y  Height of the display in pixels.
 * @param pos_x           X position to start drawing the QR code.
 * @param pos_y           Y position to start drawing the QR code.
 * @param border          Number of "modules" to add around the QR code.
 * @param scale           Scaling factor for the QR code size. Defaults to 1 (no
 * scaling).
 */
void display_draw_qr(const uint8_t qrcode[], uint16_t display_size_x,
                     uint16_t display_size_y, uint16_t pos_x, uint16_t pos_y,
                     int border, int scale) {
  // Get the display buffer address
  uint8_t *display_address = u8g2_buffer;

  // Get the native size of the QR code
  int size = qrcodegen_getSize(qrcode);

  // Clear or initialize the display buffer if needed (optional)
  // Example: memset(display_address, 0, (display_size_x / 8) * display_size_y);

  // Calculate total size in pixels (QR code modules + border) * scale
  int total_size_in_pixels = (size + 2 * border) * scale;

  // Loop through each pixel in the scaled QR code + border
  // Note: y and x indices are in 'pixel' units, not 'modules'.
  for (int y = 0; y < total_size_in_pixels; y++) {
    for (int x = 0; x < total_size_in_pixels; x++) {
      // Center the QR code by offsetting the position
      // We subtract half of the total scaled size from the center of the
      // display
      int abs_x = pos_x + x + (display_size_x - total_size_in_pixels) / 2;
      int abs_y = pos_y + y + (display_size_y - total_size_in_pixels) / 2;

      // Ensure we are within display bounds
      if (abs_x >= 0 && abs_x < (display_size_x + pos_x) && abs_y >= 0 &&
          abs_y < (display_size_y + pos_y)) {
        // Determine the tile (byte) and bit within the display buffer
        int tile_x = abs_x / 8;
        int bit = 7 - (abs_x % 8);
        int address = (abs_y * (DISPLAY_WIDTH / 8)) + tile_x;

        // Translate scaled/bordered pixel coordinates back to original QR
        // modules: (x / scale) - border and (y / scale) - border will give us
        // which original QR module this pixel belongs to.
        int module_x = (x / scale) - border;
        int module_y = (y / scale) - border;

        // Check if we're within the QR code module area
        bool is_within_qr = (module_x >= 0 && module_x < size) &&
                            (module_y >= 0 && module_y < size);

        // If within the original QR code area, get the module state
        bool module_on = false;
        if (is_within_qr) {
          module_on = qrcodegen_getModule(qrcode, module_x, module_y);
        }

        // Set or clear the bit accordingly
        if (module_on) {
          display_address[address] |= (1 << bit);
        } else {
          display_address[address] &= ~(1 << bit);
        }
      }
    }
  }
}

void display_create_qr(uint8_t qrcode[], const char *text) {
  enum qrcodegen_Ecc errCorLvl = qrcodegen_Ecc_LOW;  // Error correction level
  // Make and print the QR Code symbol
  uint8_t tempBuffer[DISPLAY_QR_BUFFER_LEN_MAX];
  bool ok = qrcodegen_encodeText(text, tempBuffer, qrcode, errCorLvl,
                                 qrcodegen_VERSION_MIN, qrcodegen_VERSION_MAX,
                                 qrcodegen_Mask_AUTO, true);
}

// Initialize u8g2 with the custom buffer
void display_setup_u8g2() {
  DPRINTF("Initializing u8g2 with a buffer size of %d bytes\n",
          DISPLAY_BUFFER_SIZE);

  set_display_address((unsigned int)&__rom_in_ram_start__ +
                      DISPLAY_BUFFER_OFFSET);
  set_display_command_address((unsigned int)&__rom_in_ram_start__ +
                              DISPLAY_BUFFER_OFFSET +
                              DISPLAY_COMMAND_ADDRESS_OFFSET);
  set_displays_highres_transtable_address((unsigned int)&__rom_in_ram_start__ +
                                          DISPLAY_HIGHRES_TRANSTABLE_OFFSET);
  DPRINTF("Display command address: 0x%08x\n", get_display_command_address());
  DPRINTF("Highres translation table address: 0x%08x\n",
          get_displays_highres_transtable_address());

#ifdef DISPLAY_ATARIST
  // We need to generate the mask table for the Atari ST display (faster highres
  // mode)
  display_generate_mask_table(get_displays_highres_transtable_address());

  // We clear the command address just in case
  SEND_COMMAND_TO_DISPLAY(DISPLAY_COMMAND_NOP);
#endif

  u8g2_SetupDisplay(&u8g2, u8x8_d_custom, (u8x8_msg_cb)u8x8_cad_dummy,
                    (u8x8_msg_cb)u8x8_dummy_byte, (u8x8_msg_cb)u8x8_dummy_gpio);

  // Calculate tile buffer height
  uint8_t tile_buf_height = DISPLAY_HEIGHT / 8;

  u8g2_SetupBuffer(&u8g2, u8g2_buffer, tile_buf_height,
                   u8g2_ll_hvline_horizontal_right_lsb, U8G2_R0);

  // Fake initialization sequence
  u8g2_InitDisplay(&u8g2);  // Initialize display (will use dummy callbacks)
}

void display_refresh() {
  uint32_t *display_buffer = (void *)get_display_address();
  COPY_AND_SWAP_16BIT_DMA(display_buffer, (uint16_t *)u8g2_buffer,
                          DISPLAY_BUFFER_SIZE);
}

void display_draw_product_info() {
  // Product info
  char product_str[80] = {0};
  u8g2_SetFont(&u8g2, u8g2_font_squeezed_b7_tr);
  snprintf(product_str, sizeof(product_str), "%s %s - %s", DISPLAY_PRODUCT_MSG,
           RELEASE_VERSION, DISPLAY_COPYRIGHT_MESSAGE);
  u8g2_DrawStr(&u8g2, LEFT_PADDING_FOR_CENTER(product_str, 68) * 6,
               DISPLAY_HEIGHT, product_str);
}

void display_generate_mask_table(uint32_t memory_address) {
  for (int i = 0; i < 256; i++) {
    unsigned int mask = 0;

    // Duplicate each bit of the 8-bit number into two bits
    for (int b = 0; b < 8; b++) {
      if (i & (1 << b)) {
        mask |= (3 << (2 * b));  // Duplicate the bit at position b
      }
    }

    // Store the 16 bit result mask in the memory address
#if DISPLAY_HIGHRES_INVERT == 1
    WRITE_WORD(memory_address, i * 2, ~mask);
#else
    WRITE_WORD(memory_address, i * 2, mask);
#endif
  }
}

// Scroll up the display buffer by blanking out the bottom part
// blank_bytes is the number of bytes to blank out at the bottom of the screen
// They should be the same as the number of bytes in a row of chars
void display_scrollup(uint16_t blank_bytes) {
  // blank bytes is the number of bytes to blank out at the bottom of the screen
  memmove(u8g2_buffer, u8g2_buffer + blank_bytes,
          DISPLAY_BUFFER_SIZE - blank_bytes);
  memset(u8g2_buffer + DISPLAY_BUFFER_SIZE - blank_bytes, 0, blank_bytes);
}
/**
 * File: mngr_display.c
 * Author: Diego Parrilla Santamar√≠a
 * Date: December 2024
 * Copyright: 2024 - GOODDATA LABS SL
 * Description: HTTPD server functions for fabric display functions
 */

#include "mngr_display.h"

// Static assert to ensure buffer size fits within uint32_t
_Static_assert(DISPLAY_BUFFER_SIZE <= UINT32_MAX,
               "Buffer size exceeds allowed limits");

// Allocate the framebuffer
static unsigned char u8g2_buffer[DISPLAY_BUFFER_SIZE] = {0};

// Global u8g2 structure
static u8g2_t u8g2 = {0};

static char url_ip[128] = {0};
static char url_host[128] = {0};

// Dummy byte communication function
static unsigned char u8x8_dummy_byte(void *u8x8, unsigned char msg,
                                     unsigned char arg_int, void *arg_ptr) {
  return 1;  // Always return success
}

// Dummy GPIO function
static unsigned char u8x8_dummy_gpio(void *u8x8, unsigned char msg,
                                     unsigned char arg_int, void *arg_ptr) {
  return 1;  // Always return success
}

// Dummy Command/Data function
static unsigned char u8x8_cad_dummy(void *u8x8, unsigned char msg,
                                    unsigned char arg_int, void *arg_ptr) {
  return 1;  // Always return success
}

#ifdef DISPLAY_ATARIST
static const u8x8_display_info_t u8x8_ataristlow_320x200_display_info = {
    /* chip_enable_level = */ 0,
    /* chip_disable_level = */ 1,

    /* post_chip_enable_wait_ns = */ 30, /* G242CX Datasheet p5 */
    /* pre_chip_disable_wait_ns = */ 10, /* G242CX Datasheet p5 */
    /* reset_pulse_width_ms = */ 1,
    /* post_reset_wait_ms = */ 6,
    /* sda_setup_time_ns = */ 20,
    /* sck_pulse_width_ns = */ 140,
    /* sck_clock_hz = */ 1000000UL, /* since Arduino 1.6.0, the SPI bus speed in
                                       Hz. Should be
                                       1000000000/sck_pulse_width_ns */
    /* spi_mode = */ 0,
    /* i2c_bus_clock_100kHz = */ 4,
    /* data_setup_time_ns = */ 120,   /* G242CX Datasheet p5 */
    /* write_pulse_width_ns = */ 220, /* G242CX Datasheet p5 */
    /* tile_width = */ 40,
    /* tile_height = */ 25,
    /* default_x_offset = */ 0,
    /* flipmode_x_offset = */ 0,
    /* pixel_width = */ 320,
    /* pixel_height = */ 200};

unsigned char u8x8_d_custom(u8x8_t *u8x8, unsigned char msg,
                            unsigned char arg_int, void *arg_ptr) {
  if (msg == U8X8_MSG_DISPLAY_SETUP_MEMORY) {
    u8x8_d_helper_display_setup_memory(u8x8,
                                       &u8x8_ataristlow_320x200_display_info);
  }
  return 1;
}
#endif

/**
 * @brief Displays a QR code onto a bitmap buffer with support for border and
 * scaling.
 *
 * @param qrcode          The QR code data generated by qrcodegen.
 * @param display_address Pointer to the display buffer (bitmap array).
 * @param display_size_x  Width of the display in pixels.
 * @param display_size_y  Height of the display in pixels.
 * @param pos_x           X position to start drawing the QR code.
 * @param pos_y           Y position to start drawing the QR code.
 * @param border          Number of "modules" to add around the QR code.
 * @param scale           Scaling factor for the QR code size. Defaults to 1 (no
 * scaling).
 */
void display_qr(const uint8_t qrcode[], uint8_t display_address[],
                uint16_t display_size_x, uint16_t display_size_y,
                uint16_t pos_x, uint16_t pos_y, int border, int scale) {
  // Get the native size of the QR code
  int size = qrcodegen_getSize(qrcode);

  // Clear or initialize the display buffer if needed (optional)
  // Example: memset(display_address, 0, (display_size_x / 8) * display_size_y);

  // Calculate total size in pixels (QR code modules + border) * scale
  int total_size_in_pixels = (size + 2 * border) * scale;

  // Loop through each pixel in the scaled QR code + border
  // Note: y and x indices are in 'pixel' units, not 'modules'.
  for (int y = 0; y < total_size_in_pixels; y++) {
    for (int x = 0; x < total_size_in_pixels; x++) {
      // Center the QR code by offsetting the position
      // We subtract half of the total scaled size from the center of the
      // display
      int abs_x = pos_x + x + (display_size_x - total_size_in_pixels) / 2;
      int abs_y = pos_y + y + (display_size_y - total_size_in_pixels) / 2;

      // Ensure we are within display bounds
      if (abs_x >= 0 && abs_x < (display_size_x + pos_x) && abs_y >= 0 &&
          abs_y < (display_size_y + pos_y)) {
        // Determine the tile (byte) and bit within the display buffer
        int tile_x = abs_x / 8;
        int bit = 7 - (abs_x % 8);
        int address = (abs_y * (DISPLAY_WIDTH / 8)) + tile_x;

        // Translate scaled/bordered pixel coordinates back to original QR
        // modules: (x / scale) - border and (y / scale) - border will give us
        // which original QR module this pixel belongs to.
        int module_x = (x / scale) - border;
        int module_y = (y / scale) - border;

        // Check if we're within the QR code module area
        bool is_within_qr = (module_x >= 0 && module_x < size) &&
                            (module_y >= 0 && module_y < size);

        // If within the original QR code area, get the module state
        bool module_on = false;
        if (is_within_qr) {
          module_on = qrcodegen_getModule(qrcode, module_x, module_y);
        }

        // Set or clear the bit accordingly
        if (module_on) {
          display_address[address] |= (1 << bit);
        } else {
          display_address[address] &= ~(1 << bit);
        }
      }
    }
  }
}

void create_qr(uint8_t qrcode[], const char *text) {
  enum qrcodegen_Ecc errCorLvl = qrcodegen_Ecc_LOW;  // Error correction level
  // Make and print the QR Code symbol
  uint8_t tempBuffer[DISPLAY_QR_BUFFER_LEN_MAX];
  bool ok = qrcodegen_encodeText(text, tempBuffer, qrcode, errCorLvl,
                                 qrcodegen_VERSION_MIN, qrcodegen_VERSION_MAX,
                                 qrcodegen_Mask_AUTO, true);
}

// Initialize u8g2 with the custom buffer
void setup_u8g2_custom() {
  DPRINTF("Initializing u8g2 with a buffer size of %d bytes\n",
          DISPLAY_BUFFER_SIZE);

  u8g2_SetupDisplay(&u8g2, u8x8_d_custom, (u8x8_msg_cb)u8x8_cad_dummy,
                    (u8x8_msg_cb)u8x8_dummy_byte, (u8x8_msg_cb)u8x8_dummy_gpio);

  // Calculate tile buffer height
  uint8_t tile_buf_height = DISPLAY_HEIGHT / 8;

  u8g2_SetupBuffer(&u8g2, u8g2_buffer, tile_buf_height,
                   u8g2_ll_hvline_horizontal_right_lsb, U8G2_R0);

  // Fake initialization sequence
  u8g2_InitDisplay(&u8g2);  // Initialize display (will use dummy callbacks)
}

void draw_product_info() {
  // Product info
  char product_str[80] = {0};
  u8g2_SetFont(&u8g2, u8g2_font_squeezed_b7_tr);
  snprintf(product_str, sizeof(product_str), "%s %s - %s", DISPLAY_PRODUCT_MSG,
           RELEASE_VERSION, DISPLAY_COPYRIGHT_MESSAGE);
  u8g2_DrawStr(&u8g2, LEFT_PADDING_FOR_CENTER(product_str, 68) * 6,
               DISPLAY_HEIGHT, product_str);
}

// Draw graphics into the buffer
void draw_connection_step1_scr(const uint8_t qrcode_wifi[], const char *ssid,
                               const char *password, const char *auth,
                               uint8_t wifi_status) {
  // // Clear the buffer first
  u8g2_ClearBuffer(&u8g2);

  display_qr(qrcode_wifi, u8g2_buffer, DISPLAY_WIDTH / 2, DISPLAY_HEIGHT, 0, 0,
             DISPLAY_QR_BORDER, DISPLAY_QR_SCALE);

  // Connection info
  char ssid_str[40] = {0};
  char auth_str[40] = {0};
  char pass_str[40] = {0};
  snprintf(ssid_str, sizeof(ssid_str), "SSID: %s", ssid);
  snprintf(pass_str, sizeof(pass_str), "Pass: %s", password);

  // Use Amstrad CPC font!
  u8g2_SetFont(&u8g2, u8g2_font_amstrad_cpc_extended_8f);
  u8g2_DrawStr(&u8g2,
               LEFT_PADDING_FOR_CENTER(ssid_str, DISPLAY_TILES_WIDTH / 2) * 8,
               32, ssid_str);
  if (strcmp(auth, "OPEN") != 0) {
    u8g2_DrawStr(&u8g2,
                 LEFT_PADDING_FOR_CENTER(pass_str, DISPLAY_TILES_WIDTH / 2) * 8,
                 40, pass_str);
  }

  // Wifi status
  mngr_display_wifi_change_status(wifi_status);

  // Steps info
  u8g2_SetFont(&u8g2, u8g2_font_squeezed_b7_tr);
  u8g2_DrawStr(&u8g2,
               LEFT_PADDING_FOR_CENTER(DISPLAY_CONNECTION_STEP1_MSG, 34) * 5, 8,
               DISPLAY_CONNECTION_STEP1_MSG);

  // Product info
  draw_product_info();

  // ByPass message
  u8g2_DrawStr(&u8g2, LEFT_PADDING_FOR_CENTER(DISPLAY_BYPASS_MESSAGE, 68) * 5,
               DISPLAY_HEIGHT - 8, DISPLAY_BYPASS_MESSAGE);

  // Frames
  u8g2_DrawRFrame(&u8g2, 0, 16, 156, 168, 8);
}

// Draw graphics into the buffer
void draw_connection_step2_scr(const uint8_t qrcode_url[], const char *url1,
                               const char *url2) {
  display_qr(qrcode_url, u8g2_buffer, DISPLAY_WIDTH / 2, DISPLAY_HEIGHT, 160, 0,
             DISPLAY_QR_BORDER, DISPLAY_QR_SCALE);

  // URL
  u8g2_DrawStr(&u8g2,
               160 + LEFT_PADDING_FOR_CENTER(url1, DISPLAY_TILES_WIDTH / 2) * 8,
               32, url1);
  u8g2_DrawStr(&u8g2,
               160 + LEFT_PADDING_FOR_CENTER(url2, DISPLAY_TILES_WIDTH / 2) * 8,
               40, url2);

  // Steps info
  u8g2_SetFont(&u8g2, u8g2_font_squeezed_b7_tr);
  u8g2_DrawStr(
      &u8g2,
      160 + LEFT_PADDING_FOR_CENTER(DISPLAY_CONNECTION_STEP2_MSG, 34) * 5, 8,
      DISPLAY_CONNECTION_STEP2_MSG);

  // Frames
  u8g2_DrawRFrame(&u8g2, 164, 16, 156, 168, 8);
}

void draw_reset_scr() {
  // Clear the buffer first
  u8g2_ClearBuffer(&u8g2);

  // Use Amstrad CPC font!
  u8g2_SetFont(&u8g2, u8g2_font_amstrad_cpc_extended_8f);
  u8g2_DrawStr(
      &u8g2,
      LEFT_PADDING_FOR_CENTER(DISPLAY_RESET_WAIT_MESSAGE, DISPLAY_TILES_WIDTH) *
          8,
      100, DISPLAY_RESET_WAIT_MESSAGE);
  u8g2_DrawStr(&u8g2,
               LEFT_PADDING_FOR_CENTER(DISPLAY_RESET_FORCE_MESSAGE,
                                       DISPLAY_TILES_WIDTH) *
                   8,
               108, DISPLAY_RESET_FORCE_MESSAGE);

  // Product info
  draw_product_info();
}

// Change the wifi status in the buffer
void mngr_display_wifi_change_status(uint8_t wifi_status) {
  // Use 8x8 font
  u8g2_SetFont(&u8g2, u8g2_font_amstrad_cpc_extended_8f);
  // Wifi status
  char wifi_status_str[20] = {0};
  switch (wifi_status) {
    case 0:
      snprintf(wifi_status_str, sizeof(wifi_status_str), "Starting WIFI...");
      break;
    case 1:
      snprintf(wifi_status_str, sizeof(wifi_status_str), "   WIFI Ready   ");
      break;
    case 2:
      snprintf(wifi_status_str, sizeof(wifi_status_str), "   Connected!   ");
      break;
  }
  u8g2_DrawStr(&u8g2, LEFT_PADDING_FOR_CENTER(wifi_status_str, 20) * 8,
               DISPLAY_HEIGHT - 24, wifi_status_str);
}

// Change the portal status in the buffer
void mngr_display_portal_change_status(uint8_t portal_status) {
  // Use 8x8 font
  u8g2_SetFont(&u8g2, u8g2_font_amstrad_cpc_extended_8f);
  // Wifi status
  char portal_status_str[20] = {0};
  switch (portal_status) {
    case 0:
      snprintf(portal_status_str, sizeof(portal_status_str),
               "Starting Portal...");
      break;
    case 1:
      snprintf(portal_status_str, sizeof(portal_status_str),
               "   Portal Ready   ");
      break;
    case 2:
      snprintf(portal_status_str, sizeof(portal_status_str),
               "   Connected!   ");
      break;
  }
  u8g2_DrawStr(&u8g2, 160 + LEFT_PADDING_FOR_CENTER(portal_status_str, 20) * 8,
               DISPLAY_HEIGHT - 24, portal_status_str);
}

void mngr_display_refresh_display() {
  uint32_t *display_buffer = (uint32_t *)&__rom_in_ram_start__;
  // increment 64K bytes to get the second 64K block
  display_buffer += 0x10000 / sizeof(uint32_t);
  COPY_AND_SWAP_16BIT_DMA(display_buffer, (uint16_t *)u8g2_buffer,
                          DISPLAY_BUFFER_SIZE);
}

// The main function should be as follows:
void mngr_display_start(const char *ssid, const char *password,
                        const char *auth, const char *url1, const char *url2) {
  // Safely copy url1 and url2 into static buffers
  snprintf(url_ip, sizeof(url_ip), "%s", url1 ? url1 : "");
  snprintf(url_host, sizeof(url_host), "%s", url2 ? url2 : "");

  size_t buffer_size = DISPLAY_BUFFER_SIZE;  // Safe usage
  (void)buffer_size;  // To avoid unused variable warning if not used elsewhere

  // Initialize the u8g2 library for a custom buffer
  setup_u8g2_custom();

  // Create the QR codes
  uint8_t qrcode_wifi[DISPLAY_QR_BUFFER_LEN_MAX];
  char qr_text[256];
  snprintf(qr_text, sizeof(qr_text), "WIFI:T:%s;S:%s;P:%s;;", auth, ssid,
           password);  // WiFi information
  DPRINTF("QR WIFI text: %s\n", qr_text);
  create_qr(qrcode_wifi, qr_text);

  // Set the flag to NOT-RESET the computer
  WRITE_LONGWORD(get_display_command_address(), 0, 0x0);

  draw_connection_step1_scr(qrcode_wifi, ssid, password, auth, 0);
  mngr_display_refresh_display();

  DPRINTF("Exiting fabric display\n");
}

void mngr_display_portal_connection() {
  // Create the QR codes
  uint8_t qrcode_url[DISPLAY_QR_BUFFER_LEN_MAX];
  char qr_text[256];
  snprintf(qr_text, sizeof(qr_text), url_ip);  // URL portal
  DPRINTF("QR URL text: %s\n", qr_text);
  create_qr(qrcode_url, qr_text);

  draw_connection_step2_scr(qrcode_url, url_ip, url_host);
  mngr_display_refresh_display();
}

void mngr_display_reset() {
  // Show reset and force message
  draw_reset_scr();
  mngr_display_refresh_display();
}

void mngr_display_generate_mask_table(uint32_t memory_address) {
  for (int i = 0; i < 256; i++) {
    unsigned int mask = 0;

    // Duplicate each bit of the 8-bit number into two bits
    for (int b = 0; b < 8; b++) {
      if (i & (1 << b)) {
        mask |= (3 << (2 * b));  // Duplicate the bit at position b
      }
    }

    // Store the 16 bit result mask in the memory address
#if DISPLAY_HIGHRES_INVERT == 1
    WRITE_WORD(memory_address, i * 2, ~mask);
#else
    WRITE_WORD(memory_address, i * 2, mask);
#endif
  }
}